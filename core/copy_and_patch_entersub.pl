#!/usr/bin/env perl

use strict;
use warnings;
use autodie qw(open close unlink);

use Git::Repository;

my @versions = qw(
    5.10.0
    5.10.1

    5.12.0
    5.12.1
    5.12.2
    5.12.3
    5.12.4
    5.12.5

    5.14.0
    5.14.1
    5.14.2
    5.14.3
    5.14.4

    5.16.0
    5.16.1
    5.16.2
    5.16.3

    5.18.0
    5.18.1
    5.18.2
    5.18.3
    5.18.4

    5.20.0
    5.20.1
    5.20.2
    5.20.3

    5.22.0
    5.22.1
    5.22.2

    5.24.0
);

my $wd = $ARGV[0];
if (!$wd || !-d $wd || !-d "$wd/.git") {
    print STDERR <<"EOT";
Usage: perl core/copy_and_patch.pl /path/to/perl5
EOT
    exit 1;
}

my $repo = Git::Repository->new(git_dir => "$wd/.git");
my (@code, $previous);

for my $version (@versions) {
    my (undef, $perl_version, $perl_patchlevel) = split /\./, $version;
    my $tag = $perl_version >= 12 ? "v$version" : "perl-$version";
    my $source = get_and_patch_pp_entersub($tag);

    if ($previous && $previous eq $source) {
        $code[-1]{version_until} = $perl_version;
        $code[-1]{patchlevel_until} = $perl_patchlevel;
    } else {
        push @code, {
            version_from        => $perl_version,
            patchlevel_from     => $perl_patchlevel,
            version_until       => $perl_version,
            patchlevel_until    => $perl_patchlevel,
            source              => $source,
        };
        $previous = $source;
    }
}

unlink $_ for glob("core/pp_hot-*.c");

my $includes = '';
for my $item (@code) {
    my ($v_from, $p_from, $v_until, $p_until) = @{$item}{qw(
        version_from
        patchlevel_from
        version_until
        patchlevel_until
    )};
    my $fname = "pp_hot-5.${v_from}.${p_from}-5.${v_until}.${p_until}.c";

    $includes .= <<"EOT";
#elif ((PERL_VERSION == $v_from && PERL_PATCHLEVEL >= $p_from) || (PERL_VERSION > $v_from)) && ((PERL_VERSION == $v_until && PERL_PATCHLEVEL <= $p_until) || (PERL_VERSION < $v_until))
    #include "$fname"

EOT
    open my $fh, ">", "core/$fname";
    print $fh $item->{source};
    close $fh;
}

open my $fh, ">", "core/patched_pp_hot.c";
print $fh <<"EOT";
#if 0
    /* simplify code generation */

$includes
#else
    #define NO_PATCHED_ENTERSUB
#endif
EOT
close $fh;

sub get_and_patch_pp_entersub {
    my ($tag) = @_;
    my $pp_hot = $repo->run('show', "$tag:pp_hot.c");
    my ($pp_entersub) = $pp_hot =~ m/^(PP\(pp_entersub\).*?^})$/ms;

    die "Unable to find pp_entersub definition in pp_hot.c ($tag)"
        unless $pp_entersub;

# TABs are intentional here
my $patch = <<"EOT";
	if (dbg_callback) {
	    Perl_get_db_sub(aTHX_ &sv, cv);
	    dbg_callback(aTHX);
	} else if (GvCV(PL_DBsub)) {
EOT

    $pp_entersub =~ s{^PP\(pp_entersub\)}{PP(pp_entersub_copy)}
        or die "Unable to rename pp_entersub ($tag)";
    # strip away the && GvCV(PL_DBsub) && (included in $patch above)
    $pp_entersub =~ s{\QOPpENTERSUB_DB) && GvCV(PL_DBsub)\E\s+&&}{OPpENTERSUB_DB) &&}
        or die "Unable to remove GvCV(PL_DBsub) check ($tag)";
    # move the body of the if () in the "else" branch of $patch
    # indentation is not perfect, but good enough for readable code
    $pp_entersub =~ s{^\s+(\QPerl_get_db_sub(aTHX_ &sv, cv);\E\n)(.*?\n)(    \})$}{"$patch\t    $1" . indent($2) . "\t\}\n$3"}mse
        or die "Unable to add call to dbg_callback() ($tag)";

return <<"EOT";
/*
   GENERATED BY copy_and_patch_entersub.pl, DON'T MODIFY.

   Modified version of code from pp_hot.c, in the Perl core.

   Copyright (C) Larry Wall and others.

   You may distribute under the terms of either the GNU General Public
   License or the Artistic License.

 */

#define PERL_SUB_DEPTH_WARN 100
#define pad_push(a,b)           Perl_pad_push(aTHX_ a,b)
#define sub_crush_depth(a)      Perl_sub_crush_depth(aTHX_ a)
#if PERL_VERSION < 12
#define cxinc()                 Perl_cxinc(aTHX)
#endif
#if PERL_VERSION >= 20
#define newSVavdefelem(a,b,c)   Perl_newSVavdefelem(aTHX_ a,b,c)
#endif

$pp_entersub
EOT
}

sub indent {
    my ($text) = @_;

    $text =~ s{^(\t| {8})}{\t    }mg;

    return $text;
}
