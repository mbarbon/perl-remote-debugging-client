/*
   GENERATED BY copy_and_patch_entersub.pl, DON'T MODIFY.

   Modified version of code from pp_hot.c, in the Perl core.

   Copyright (C) Larry Wall and others.

   You may distribute under the terms of either the GNU General Public
   License or the Artistic License.

 */

#define PERL_SUB_DEPTH_WARN 100
#define pad_push(a,b)           Perl_pad_push(aTHX_ a,b)
#define sub_crush_depth(a)      Perl_sub_crush_depth(aTHX_ a)
#if PERL_VERSION < 12
#define cxinc()                 Perl_cxinc(aTHX)
#endif
#if PERL_VERSION >= 20
#define newSVavdefelem(a,b,c)   Perl_newSVavdefelem(aTHX_ a,b,c)
#endif

PP(pp_entersub_copy)
{
    dSP; dPOPss;
    GV *gv;
    CV *cv;
    PERL_CONTEXT *cx;
    I32 gimme;
    const bool hasargs = (PL_op->op_flags & OPf_STACKED) != 0;

    if (UNLIKELY(!sv))
	DIE(aTHX_ "Not a CODE reference");
    /* This is overwhelmingly the most common case:  */
    if (!LIKELY(SvTYPE(sv) == SVt_PVGV && (cv = GvCVu((const GV *)sv)))) {
        switch (SvTYPE(sv)) {
        case SVt_PVGV:
          we_have_a_glob:
            if (!(cv = GvCVu((const GV *)sv))) {
                HV *stash;
                cv = sv_2cv(sv, &stash, &gv, 0);
            }
            if (!cv) {
                ENTER;
                SAVETMPS;
                goto try_autoload;
            }
            break;
        case SVt_PVLV:
            if(isGV_with_GP(sv)) goto we_have_a_glob;
            /* FALLTHROUGH */
        default:
            if (sv == &PL_sv_yes) {		/* unfound import, ignore */
                if (hasargs)
                    SP = PL_stack_base + POPMARK;
                else
                    (void)POPMARK;
                RETURN;
            }
            SvGETMAGIC(sv);
            if (SvROK(sv)) {
                if (SvAMAGIC(sv)) {
                    sv = amagic_deref_call(sv, to_cv_amg);
                    /* Don't SPAGAIN here.  */
                }
            }
            else {
                const char *sym;
                STRLEN len;
                if (!SvOK(sv))
                    DIE(aTHX_ PL_no_usym, "a subroutine");
                sym = SvPV_nomg_const(sv, len);
                if (PL_op->op_private & HINT_STRICT_REFS)
                    DIE(aTHX_ "Can't use string (\"%" SVf32 "\"%s) as a subroutine ref while \"strict refs\" in use", sv, len>32 ? "..." : "");
                cv = get_cvn_flags(sym, len, GV_ADD|SvUTF8(sv));
                break;
            }
            cv = MUTABLE_CV(SvRV(sv));
            if (SvTYPE(cv) == SVt_PVCV)
                break;
            /* FALLTHROUGH */
        case SVt_PVHV:
        case SVt_PVAV:
            DIE(aTHX_ "Not a CODE reference");
            /* This is the second most common case:  */
        case SVt_PVCV:
            cv = MUTABLE_CV(sv);
            break;
        }
    }

    ENTER;

  retry:
    if (UNLIKELY(CvCLONE(cv) && ! CvCLONED(cv)))
	DIE(aTHX_ "Closure prototype called");
    if (UNLIKELY(!CvROOT(cv) && !CvXSUB(cv))) {
	GV* autogv;
	SV* sub_name;

	/* anonymous or undef'd function leaves us no recourse */
	if (CvLEXICAL(cv) && CvHASGV(cv))
	    DIE(aTHX_ "Undefined subroutine &%"SVf" called",
		       SVfARG(cv_name(cv, NULL, 0)));
	if (CvANON(cv) || !CvHASGV(cv)) {
	    DIE(aTHX_ "Undefined subroutine called");
	}

	/* autoloaded stub? */
	if (cv != GvCV(gv = CvGV(cv))) {
	    cv = GvCV(gv);
	}
	/* should call AUTOLOAD now? */
	else {
          try_autoload:
	    if ((autogv = gv_autoload_pvn(GvSTASH(gv), GvNAME(gv), GvNAMELEN(gv),
				   GvNAMEUTF8(gv) ? SVf_UTF8 : 0)))
	    {
		cv = GvCV(autogv);
	    }
	    else {
	       sorry:
		sub_name = sv_newmortal();
		gv_efullname3(sub_name, gv, NULL);
		DIE(aTHX_ "Undefined subroutine &%"SVf" called", SVfARG(sub_name));
	    }
	}
	if (!cv)
	    goto sorry;
	goto retry;
    }

    if (UNLIKELY((PL_op->op_private & OPpENTERSUB_DB) && !CvNODEBUG(cv)))
    {
	if (dbg_callback) {
	    Perl_get_db_sub(aTHX_ &sv, cv);
	    dbg_callback(aTHX);
	} else if (GvCV(PL_DBsub)) {
	    Perl_get_db_sub(aTHX_ &sv, cv);
	     if (CvISXSUB(cv))
	         PL_curcopdb = PL_curcop;
	     if (CvLVALUE(cv)) {
	         /* check for lsub that handles lvalue subroutines */
	         cv = GvCV(gv_fetchpvs("DB::lsub", GV_ADDMULTI, SVt_PVCV));
	         /* if lsub not found then fall back to DB::sub */
	         if (!cv) cv = GvCV(PL_DBsub);
	     } else {
	         cv = GvCV(PL_DBsub);
	     }

	    if (!cv || (!CvXSUB(cv) && !CvSTART(cv)))
	        DIE(aTHX_ "No DB::sub routine defined");
	}
    }

    gimme = GIMME_V;

    if (!(CvISXSUB(cv))) {
	/* This path taken at least 75% of the time   */
	dMARK;
	PADLIST * const padlist = CvPADLIST(cv);
        I32 depth;

	PUSHBLOCK(cx, CXt_SUB, MARK);
	PUSHSUB(cx);
	cx->blk_sub.retop = PL_op->op_next;
	if (UNLIKELY((depth = ++CvDEPTH(cv)) >= 2)) {
	    PERL_STACK_OVERFLOW_CHECK();
	    pad_push(padlist, depth);
	}
	SAVECOMPPAD();
	PAD_SET_CUR_NOSAVE(padlist, depth);
	if (LIKELY(hasargs)) {
	    AV *const av = MUTABLE_AV(PAD_SVl(0));
            SSize_t items;
            AV **defavp;

	    if (UNLIKELY(AvREAL(av))) {
		/* @_ is normally not REAL--this should only ever
		 * happen when DB::sub() calls things that modify @_ */
		av_clear(av);
		AvREAL_off(av);
		AvREIFY_on(av);
	    }
	    defavp = &GvAV(PL_defgv);
	    cx->blk_sub.savearray = *defavp;
	    *defavp = MUTABLE_AV(SvREFCNT_inc_simple_NN(av));
	    CX_CURPAD_SAVE(cx->blk_sub);
	    cx->blk_sub.argarray = av;
            items = SP - MARK;

	    if (UNLIKELY(items - 1 > AvMAX(av))) {
                SV **ary = AvALLOC(av);
                AvMAX(av) = items - 1;
                Renew(ary, items, SV*);
                AvALLOC(av) = ary;
                AvARRAY(av) = ary;
            }

	    Copy(MARK+1,AvARRAY(av),items,SV*);
	    AvFILLp(av) = items - 1;
	
	    MARK = AvARRAY(av);
	    while (items--) {
		if (*MARK)
		{
		    if (SvPADTMP(*MARK)) {
			*MARK = sv_mortalcopy(*MARK);
                    }
		    SvTEMP_off(*MARK);
		}
		MARK++;
	    }
	}
	SAVETMPS;
	if (UNLIKELY((cx->blk_u16 & OPpENTERSUB_LVAL_MASK) == OPpLVAL_INTRO &&
	    !CvLVALUE(cv)))
	    DIE(aTHX_ "Can't modify non-lvalue subroutine call");
	/* warning must come *after* we fully set up the context
	 * stuff so that __WARN__ handlers can safely dounwind()
	 * if they want to
	 */
	if (UNLIKELY(depth == PERL_SUB_DEPTH_WARN
                && ckWARN(WARN_RECURSION)
                && !(PERLDB_SUB && cv == GvCV(PL_DBsub))))
	    sub_crush_depth(cv);
	RETURNOP(CvSTART(cv));
    }
    else {
	SSize_t markix = TOPMARK;

	SAVETMPS;
	PUTBACK;

	if (UNLIKELY(((PL_op->op_private
	       & PUSHSUB_GET_LVALUE_MASK(Perl_is_lvalue_sub)
             ) & OPpENTERSUB_LVAL_MASK) == OPpLVAL_INTRO &&
	    !CvLVALUE(cv)))
	    DIE(aTHX_ "Can't modify non-lvalue subroutine call");

	if (UNLIKELY(!hasargs && GvAV(PL_defgv))) {
	    /* Need to copy @_ to stack. Alternative may be to
	     * switch stack to @_, and copy return values
	     * back. This would allow popping @_ in XSUB, e.g.. XXXX */
	    AV * const av = GvAV(PL_defgv);
	    const SSize_t items = AvFILL(av) + 1;

	    if (items) {
		SSize_t i = 0;
		const bool m = cBOOL(SvRMAGICAL(av));
		/* Mark is at the end of the stack. */
		EXTEND(SP, items);
		for (; i < items; ++i)
		{
		    SV *sv;
		    if (m) {
			SV ** const svp = av_fetch(av, i, 0);
			sv = svp ? *svp : NULL;
		    }
		    else sv = AvARRAY(av)[i];
		    if (sv) SP[i+1] = sv;
		    else {
			SP[i+1] = newSVavdefelem(av, i, 1);
		    }
		}
		SP += items;
		PUTBACK ;		
	    }
	}
	else {
	    SV **mark = PL_stack_base + markix;
	    SSize_t items = SP - mark;
	    while (items--) {
		mark++;
		if (*mark && SvPADTMP(*mark)) {
		    *mark = sv_mortalcopy(*mark);
                }
	    }
	}
	/* We assume first XSUB in &DB::sub is the called one. */
	if (UNLIKELY(PL_curcopdb)) {
	    SAVEVPTR(PL_curcop);
	    PL_curcop = PL_curcopdb;
	    PL_curcopdb = NULL;
	}
	/* Do we need to open block here? XXXX */

	/* CvXSUB(cv) must not be NULL because newXS() refuses NULL xsub address */
	assert(CvXSUB(cv));
	CvXSUB(cv)(aTHX_ cv);

	/* Enforce some sanity in scalar context. */
	if (gimme == G_SCALAR) {
            SV **svp = PL_stack_base + markix + 1;
            if (svp != PL_stack_sp) {
                *svp = svp > PL_stack_sp ? &PL_sv_undef : *PL_stack_sp;
                PL_stack_sp = svp;
            }
	}
	LEAVE;
	return NORMAL;
    }
}
